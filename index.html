<!-- <!DOCTYPE html> -->
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ascii.jpeg</title>
<link rel="stylesheet" href="ascii_jpeg.css">
</head>
<body>
<div class="container">
  <!-- jpeg headers -->
  <div class="col_headers">
    <div class="title">
      <h3>jpeg headers</h3>
    </div>
    <!-- Image Sizes -->
    <div class="box" id="image-sizes">
      <span>Size:</span>
    </div>
    <!-- Pixel Formats -->
    <div class="box" id="pixel-formats">
      <div id="pixel-formats-list">
        <span>Pixel format:</span>
      </div>
      <div id="components"></div>
    </div>
    <!-- Presets -->
    <div class="box" id="presets">
      <span>Presets:</span>
    </div>
    <!-- Texts -->
    <div class="box" id="texts">
      <span>Texts:</span>
    </div>
  </div>

  <!-- ascii -->
  <div class="col_ascii">
    <div class="title">
      <h3>ascii</h3>
    </div>
    <!-- ascii text -->
    <textarea id="textbox"></textarea>
  </div>

  <!-- output -->
  <div class="col_output">
    <div class="title">
      <h3>ascii.jpeg</h3>
    </div>
    <!-- ascii.jpeg -->
    <div class="image-row">
      <div id="jpeg-div">
        <img id="jpeg" src="" alt="ascii.jpeg">
      </div>
      <div class="button-container">
        <button id="download-jpeg">Download ascii.jpeg</button>
        <button id="download-txt">Download jpeg.txt</button>
        <button id="open-txt">Open jpeg.txt</button>
      </div>
    </div>
    <!-- baked.png -->
    <div class="image-row">
      <img id="png" src="" alt="baked.png">
      <div class="button-container">
        <button id="download-png">Download baked.png</button>
      </div>
    </div>
  </div>
</div>

<!-- Status Line -->
<div id="status"></div>

<script src="fflate-only.min.js"></script>
<script src="transliteration.min.js"></script>
<script src="ascii_text.js"></script>
<script src="ascii_jpeg.js"></script>
<script>
  const default_image_size = "16x16";
  const default_pixfmt = "YUV444";
  const default_preset = "skip DC | full range AC";
  const default_text   = "ne_me_quitte_pas";

  const encoder = new TextEncoder();
  const decoder = new TextDecoder();

  function deflate(text)
  {
    try {
      const input = encoder.encode(text);
      return fflate.deflateSync(input);
    } catch {
      return false;
    }
  }

  function inflate(compressed)
  {
    try {
      const output = fflate.inflateSync(compressed);
      return decoder.decode(output);
    } catch {
      return false;
    }
  }

  function compress_to_uri(text)
  {
    try {
      const compressed = deflate(text);
      if (!compressed)
        return false;
      let str = "";
      for (let b of compressed)
        str += String.fromCharCode(b);
      return btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, "");
    } catch {
      return false;
    }
  }

  function decompress_from_uri(b64)
  {
    try {
      b64 = b64.replace(/-/g, '+').replace(/_/g, '/');
      while (b64.length % 4)
        b64 += '=';
      const binary = atob(b64);
      const compressed = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++)
        compressed[i] = binary.charCodeAt(i);
      return inflate(compressed);
    } catch {
      return false;
    }
  }

  function download_blob(blob, name)
  {
    const blob_url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href     = blob_url;
    link.download = name;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  function open_blob(blob)
  {
    const blob_url = URL.createObjectURL(blob);
    window.open(blob_url, "jpeg.txt");
  }

  document.addEventListener("DOMContentLoaded", function() {
    const textarea   = document.getElementById("textbox");
    const statusLine = document.getElementById("status");
    const jpegImage  = document.getElementById("jpeg");
    const pngImage   = document.getElementById("png");

    let html, div;

    let dom_parameters = {};

    /* Image Sizes */
    html = "";
    for (const name in image_size_values) {
      html += `<input type="radio" id="${name}" name="image_size"${name === default_image_size ? " checked" : ""}>`;
      html += `<label class="option-label" for="${name}">${name}</label>`;
    }
    div = document.getElementById("image-sizes");
    div.insertAdjacentHTML("beforeend", html);
    dom_parameters.image_size = Array.from(div.querySelectorAll("input[name='image_size']"));

    /* Pixel Formats */
    html = "";
    for (const name in pixfmt_values) {
      html += `<input type="radio" id="${name}" name="pixfmt"${name === default_pixfmt ? " checked" : ""}>`;
      html += `<label class="option-label" for="${name}">${name}</label>`;
    }
    div = document.getElementById("pixel-formats-list");
    div.insertAdjacentHTML("beforeend", html);
    dom_parameters.pixfmt = Array.from(div.querySelectorAll("input[name='pixfmt']"));

    /* Components */
    const default_preset_values = preset_values[default_preset];
    const default_dc_dht = default_preset_values[0];
    const default_ac_dht = default_preset_values[1];
    html = "";
    for (let i = 0; i < 3; i++) {
      html += `<div class="component" id="component${i}">`;
      html += "  <table>";
      /* Labels */
      html += "    <tr>";
      html += `      <th>Component #${i + 1}</th>`;
      html += "      <th>DC</th>";
      html += "      <th>AC</th>";
      html += "    </tr>";
      /* Huffman */
      let dc_huff_options = "";
      let ac_huff_options = "";
      for (const name in dht_values) {
        dc_huff_options += `<option value="${name}"${name === default_dc_dht ? " selected" : ""}>${name}</option>`;
        ac_huff_options += `<option value="${name}"${name === default_ac_dht ? " selected" : ""}>${name}</option>`;
      }
      html += "    <tr>";
      html += "      <td>Huffman:</td>";
      html += `      <td><select name="huff_dc_${i}">${dc_huff_options}"</select></td>`;
      html += `      <td><select name="huff_ac_${i}">${ac_huff_options}"</select></td>`;
      html += "    </tr>";
      /* Quantization */
      html += "    <tr>";
      html += "      <td>Quantization:</td>";
      html += `      <td><input type="number" min="1" max="255" name="quant_dc_${i}"></td>`;
      html += `      <td><input type="number" min="1" max="255" name="quant_ac_${i}"></td>`;
      html += "    </tr>";
      html += "  </table>";
      html += "</div>";
    }
    div = document.getElementById("components");
    div.insertAdjacentHTML("beforeend", html);
    dom_parameters.components = Array.from(div.querySelectorAll('div[id^="component"]'));
    dom_parameters.huff_dc    = Array.from(div.querySelectorAll('select[name^="huff_dc"]'));
    dom_parameters.huff_ac    = Array.from(div.querySelectorAll('select[name^="huff_ac"]'));
    dom_parameters.quant_dc   = Array.from(div.querySelectorAll('input[name^="quant_dc"]'));
    dom_parameters.quant_ac   = Array.from(div.querySelectorAll('input[name^="quant_ac"]'));

    /* Presets */
    html = "";
    let preset_options = "";
    for (const name in preset_values)
      preset_options += `<option value="${name}" ${name === default_preset ? " selected" : ""}>${name}</option>`;
    html += `<select name='preset'>${preset_options}</select>`;
    div = document.getElementById("presets");
    div.insertAdjacentHTML("beforeend", html);
    dom_parameters.presets = div.querySelector('select[name="preset"]');

    /* Texts */
    html = "";
    let text_options = "";
    for (const name in text_values)
      text_options += `<option value="${name}" ${name === default_text ? " selected" : ""}>${name}</option>`;
    html += `<select name='text'>${text_options}</select>`;
    div = document.getElementById("texts");
    div.insertAdjacentHTML("beforeend", html);
    dom_parameters.texts = div.querySelector('select[name="text"]');

    dom_parameters.image_size.forEach(self => { self.addEventListener("change", update); });
    dom_parameters.pixfmt    .forEach(self => { self.addEventListener("change", updateComponents); });
    dom_parameters.huff_dc   .forEach(self => { self.addEventListener("change", updateHuff); });
    dom_parameters.huff_ac   .forEach(self => { self.addEventListener("change", updateHuff); });
    dom_parameters.quant_dc  .forEach(self => { self.addEventListener("change", updateQuant); });
    dom_parameters.quant_ac  .forEach(self => { self.addEventListener("change", updateQuant); });
    dom_parameters.presets.addEventListener("change", (e) => {
      const cur_preset = preset_values[e.target.value];
      dom_parameters.huff_dc.forEach(self => { self.value = cur_preset[0]; updateHuffQuant(self); });
      dom_parameters.huff_ac.forEach(self => { self.value = cur_preset[1]; updateHuffQuant(self); });
      update();
    });
    dom_parameters.texts.addEventListener("change", (e) => {
      textarea.value = text_values[e.target.value];
      update();
    });

    /* Set default ASCII content after ascii_jpeg.js is loaded */
    textarea.value = default_ascii;

    function updateQuant(e)
    {
      const input = e.target;
      if (input.value < 0)
        input.value = 1;
      else if (input.value > 255)
        input.value = 255;
      update();
    }

    function updateHuffQuant(select)
    {
      const split = select.name.split("_");
      const is_dc = (split[1] === "dc");
      const compn = parseInt(split[2]);
      const cur_dht = dht_values[select.value];
      const quant = cur_dht.suggested_quant;
      if (is_dc)
        dom_parameters.quant_dc[compn].value = quant;
      else
        dom_parameters.quant_ac[compn].value = quant;
    }

    function updateHuff(e)
    {
      updateHuffQuant(e.target);
      update();
    }

    function updateComponents()
    {
      const colorspace = dom_parameters.pixfmt.find(input => input.checked).id;
      const disable_chroma = (colorspace === "Grayscale");
      for (let i = 1; i < 3; i++) {
        if (disable_chroma) {
          dom_parameters.components[i].classList.add("disabled");
        } else {
          dom_parameters.components[i].classList.remove("disabled");
        }
        dom_parameters.huff_dc[i].disabled = disable_chroma;
        dom_parameters.huff_ac[i].disabled = disable_chroma;
      }
      update();
    }

    /* Attach event listener to textarea with debounce */
    let updateTimeout;
    textarea.addEventListener('input', function() {
      clearTimeout(updateTimeout);
      updateTimeout = setTimeout(update, 200);
    });

    /* The update function */
    function update() {
      /* Clear status line */
      statusLine.textContent = "";

      /* Get DOM parameters */
      const subsampling = pixfmt_values    [dom_parameters.pixfmt    .find(input => input.checked).id];
      const image_size  = image_size_values[dom_parameters.image_size.find(input => input.checked).id];

      const components = [];

      /* Get values from enabled components */
      const nb_components = subsampling.length;
      for (let i = 0; i < nb_components; i++) {
        const quant_dc = parseInt(dom_parameters.quant_dc[i].value);
        const quant_ac = parseInt(dom_parameters.quant_ac[i].value);
        const dqt = new Uint8Array(64).fill(quant_ac);
        dqt[0] = quant_dc;

        const { lengths: dc_lengths, symbols: dc_symbols } = dht_values[dom_parameters.huff_dc[i].value];
        const { lengths: ac_lengths, symbols: ac_symbols } = dht_values[dom_parameters.huff_ac[i].value];

        components.push({
          dqt: dqt,
          dht_dc: { lengths: dc_lengths, symbols: dc_symbols },
          dht_ac: { lengths: ac_lengths, symbols: ac_symbols },
          subsampling: subsampling[i],
        });
      }

      /* Get ASCII content from textarea */
      const ascii = transliterate(textarea.value);
      if (ascii != textarea.value) {
        statusLine.textContent = "Warning: non-ascii characters have been transliterated to ascii.";
      }

      /* Call ascii_jpeg() with the parameters */
      ascii_jpeg(components, ascii, image_size.width, image_size.height);

      /* Update the image dimensions */
      jpegImage.width  = image_size.width;
      jpegImage.height = image_size.height;

      // const apfelstrudel_fflate = compress_to_uri(ascii);
      // console.log(apfelstrudel_fflate);
      // console.log("fflate", ascii.length, apfelstrudel_fflate.length);
      // const blabliblu = decompress_from_uri(apfelstrudel_fflate);
      // if (!blabliblu)
      //   console.log("oopsie");
      // console.log(ascii == blabliblu);
    }

    /* Download/open buttons */
    document.getElementById("download-jpeg").addEventListener("click", () => { download_blob(window.jpeg_blob, "ascii.jpeg"); });
    document.getElementById("download-png"). addEventListener("click", () => { download_blob(window.png_blob,  "ascii_baked.png"); });
    document.getElementById('download-txt'). addEventListener("click", () => { download_blob(window.txt_blob,  "jpeg.txt"); });
    document.getElementById('open-txt').     addEventListener("click", () => { open_blob    (window.txt_blob); });

    /* Initial update */
    dom_parameters.huff_dc.forEach(self => { updateHuffQuant(self); });
    dom_parameters.huff_ac.forEach(self => { updateHuffQuant(self); });
    updateComponents();
  });
</script>

</body>
</html>
