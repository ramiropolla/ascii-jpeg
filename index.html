<!-- <!DOCTYPE html> -->
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ascii.jpeg</title>
<link rel="stylesheet" href="ascii_jpeg.css">
</head>
<body>
<div class="container">
  <!-- jpeg headers -->
  <div class="col_headers">
    <div class="title">
      <h3>jpeg headers</h3>
    </div>

    <!-- Image Sizes -->
    <div class="box" id="image-sizes">
      <span>Size:</span>
    </div>

    <!-- Pixel Formats -->
    <div class="box" id="pixel-formats">
      <div id="pixel-formats-list">
        <span>Pixel format:</span>
      </div>
      <div id="components"></div>
    </div>

    <!-- Presets -->
    <div class="box" id="presets">
      <span>Presets:</span>
    </div>

    <!-- Texts -->
    <div class="box" id="texts">
      <span>Texts:</span>
    </div>
  </div>


  <!-- ascii -->
  <div class="col_ascii">
    <div class="title">
      <h3>ascii</h3>
    </div>

    <!-- ascii text -->
    <textarea id="textbox"></textarea>
  </div>


  <!-- output -->
  <div class="col_output">
    <div class="title">
      <h3>ascii.jpeg</h3>
    </div>

    <!-- ascii.jpeg -->
    <div class="image-row">
      <div id="jpeg-div">
        <img id="jpeg" src="" alt="ascii.jpeg">
      </div>
      <div class="button-container">
        <button id="download-jpeg">Download ascii.jpeg</button>
      </div>
      <div class="button-container">
        <button id="download-txt">Download jpeg.txt</button>
      </div>
    </div>

    <!-- baked.png -->
    <div class="image-row">
      <img id="png" src="" alt="baked.png">
      <div class="button-container">
        <button id="download-png">Download baked.png</button>
      </div>
    </div>
  </div>
</div>

<!-- Status Line -->
<div id="status"></div>

<!-- Include ascii_jpeg.js -->
<script src="fflate-only.min.js"></script>
<script src="transliteration.min.js"></script>
<script src="ascii_text.js"></script>
<script src="ascii_jpeg.js"></script>

<script>
  const encoder = new TextEncoder();
  const decoder = new TextDecoder();

  function deflate(text)
  {
    try {
      const input = encoder.encode(text);
      return fflate.deflateSync(input);
    } catch {
      return false;
    }
  }

  function inflate(compressed)
  {
    try {
      const output = fflate.inflateSync(compressed);
      return decoder.decode(output);
    } catch {
      return false;
    }
  }

  function compress_to_uri(text)
  {
    try {
      const compressed = deflate(text);
      if (!compressed)
        return false;
      let str = '';
      for (let b of compressed)
        str += String.fromCharCode(b);
      return btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    } catch {
      return false;
    }
  }

  function decompress_from_uri(b64)
  {
    try {
      b64 = b64.replace(/-/g, '+').replace(/_/g, '/');
      while (b64.length % 4)
        b64 += '=';
      const binary = atob(b64);
      const compressed = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++)
        compressed[i] = binary.charCodeAt(i);
      return inflate(compressed);
    } catch {
      return false;
    }
  }
</script>

<script>
  /* JavaScript to enable/disable components and handle updates */
  document.addEventListener('DOMContentLoaded', function() {
    const default_image_size = "16x16";
    const default_pixfmt = "YUV444";
    const default_dc_dht = "[1] skip";
    const default_ac_dht = "[1] 1-6 lsbs";
    const default_preset = "none";
    const default_text = "ne_me_quitte_pas";

    let div, html;

    /* Image Sizes */
    html = "";
    for (const name in image_size_values) {
      html += `<input type="radio" id="${name}" name="image_size" ${name === default_image_size ? 'checked' : ''}>`;
      html += `<label class="option-label" for="${name}">${name}</label>`;
    }
    div = document.getElementById("image-sizes");
    div.insertAdjacentHTML("beforeend", html);
    div.querySelectorAll('input[name="image_size"]').forEach(input => {
      input.addEventListener("change", update);
    });

    /* Pixel Formats */
    html = "";
    for (const name in pixfmt_values) {
      html += `<input type="radio" id="${name}" name="pixfmt" ${name === default_pixfmt ? 'checked' : ''}>`;
      html += `<label class="option-label" for="${name}">${name}</label>`;
    }
    div = document.getElementById("pixel-formats-list");
    div.insertAdjacentHTML("beforeend", html);
    div.querySelectorAll('input[name="pixfmt"]').forEach(input => {
      input.addEventListener("change", updateComponents);
    });

    /* Components */
    html = "";
    for (let i = 0; i < 3; i++) {
      html += `<div class="component" id="component${i + 1}">`;
      html += "  <table>";
      /* Labels */
      html += "    <tr>";
      html += `      <th>Component #${i + 1}</th>`;
      html += "      <th>DC</th>";
      html += "      <th>AC</th>";
      html += "    </tr>";
      /* Huffman */
      let dc_dht_options = "";
      let ac_dht_options = "";
      for (const name in dht_values) {
        dc_dht_options += `<option value="${name}" ${name === default_dc_dht ? 'selected' : ''}>${name}</option>`;
        ac_dht_options += `<option value="${name}" ${name === default_ac_dht ? 'selected' : ''}>${name}</option>`;
      }
      html += "    <tr>";
      html += "      <td>Huffman:</td>";
      html += `      <td><select name="huff_dc_${i + 1}">${dc_dht_options}"</select></td>`;
      html += `      <td><select name="huff_ac_${i + 1}">${ac_dht_options}"</select></td>`;
      html += "    </tr>";
      html += "  </table>";
      html += "</div>";
    }
    div = document.getElementById("components");
    div.insertAdjacentHTML("beforeend", html);
    const components = div.querySelectorAll('div[id^="component"]');

    /* Presets */
    html = "";
    let preset_options = "";
    for (const name in preset_values)
      preset_options += `<option value="${name}" ${name === default_preset ? 'selected' : ''}>${name}</option>`;
    html += `<select name='preset'>${preset_options}</select>`;
    div = document.getElementById("presets");
    div.insertAdjacentHTML("beforeend", html);
    div.querySelector('select[name="preset"]').addEventListener('change', (e) => {
      const cur_preset = preset_values[e.target.value];
      if (cur_preset) {
        document.querySelectorAll('select[name^="huff_dc"]').forEach(huff_dc => { huff_dc.value = cur_preset[0]; });
        document.querySelectorAll('select[name^="huff_ac"]').forEach(huff_ac => { huff_ac.value = cur_preset[1]; });
        update();
      }
    });

    const textarea = document.getElementById('textbox');

    /* Texts */
    html = "";
    let text_options = "";
    for (const name in text_values)
      text_options += `<option value="${name}" ${name === default_text ? 'selected' : ''}>${name}</option>`;
    html += `<select name='text'>${text_options}</select>`;
    div = document.getElementById("texts");
    div.insertAdjacentHTML("beforeend", html);
    div.querySelector('select[name="text"]').addEventListener('change', (e) => {
      const cur_text = text_values[e.target.value];
      if (cur_text) {
        textarea.value = cur_text;
        update();
      }
    });

    const statusLine = document.getElementById('status');
    const jpegImage = document.getElementById('jpeg');
    const pngImage = document.getElementById('png');

    /* Set default ASCII content after ascii_jpeg.js is loaded */
    textarea.value = default_ascii;

    function updateComponents(e)
    {
      const selectedMode = document.querySelector('input[name="pixfmt"]:checked').id;
      if (selectedMode === "Grayscale") {
        enableComponent(1);
        disableComponent(2);
        disableComponent(3);
      } else {
        enableComponent(1);
        enableComponent(2);
        enableComponent(3);
      }
      update();
    }

    function enableComponent(num)
    {
      components[num - 1].classList.remove('disabled');
      components[num - 1].querySelectorAll('select').forEach(el => {
        el.disabled = false;
      });
    }

    function disableComponent(num)
    {
      components[num - 1].classList.add('disabled');
      components[num - 1].querySelectorAll('select').forEach(el => {
        el.disabled = true;
      });
    }

if ( 0 )
{
    /* Attach event listeners to Quantization selects */
    document.querySelectorAll('input[name^="quant_dc_"], input[name^="quant_ac_"]').forEach(select => {
      select.addEventListener('change', update);
    });
}

    /* Attach event listeners to Huffman selects */
    document.querySelectorAll('select[name^="huff_dc_"], select[name^="huff_ac_"]').forEach(select => {
      select.addEventListener('change', update);
    });

    /* Attach event listener to textarea with debounce */
    let updateTimeout;
    textarea.addEventListener('input', function() {
      clearTimeout(updateTimeout);
      updateTimeout = setTimeout(update, 200);
    });

    function getImageSize() {
      const selectedSizeRadio = document.querySelector('input[name="image_size"]:checked');
      if (selectedSizeRadio) {
        const sizeValue = selectedSizeRadio.id.replace('size', '');
        return parseInt(sizeValue);
      }
      return 64; /* default size */
    }

    /* The update function */
    function update() {
      /* Clear status line */
      statusLine.textContent = '';

      /* Get colorspace */
      const colorspace = document.querySelector('input[name="pixfmt"]:checked + label').textContent;

      /* Get image size */
      const imageSize = getImageSize();

      /* Initialize components array */
      const componentsArray = [];

      /* Get values from enabled components */
      const enabledComponents = document.querySelectorAll('.component:not(.disabled)');
      for (const component of enabledComponents) {
if ( 0 )
{
        const quant_dc_select = component.querySelector('input[name^="quant_dc_"]');
        const quant_ac_select = component.querySelector('input[name^="quant_ac_"]');
        const quant_dc = quant_dc_select.value;
        const quant_ac = quant_ac_select.value;
}

        const huff_dc_select = component.querySelector('select[name^="huff_dc_"]');
        const huff_ac_select = component.querySelector('select[name^="huff_ac_"]');
        const huff_dc = huff_dc_select.value;
        const huff_ac = huff_ac_select.value;

        /* Add component values as a subarray */
if ( 0 ) {
        componentsArray.push([quant_dc, quant_ac, huff_dc, huff_ac]);
} else {
        componentsArray.push([0, 0, huff_dc, huff_ac]);
}
      }

      /* Get ASCII content from textarea */
      const ascii = transliterate(textarea.value);
      if (ascii != textarea.value) {
        statusLine.textContent = "Warning: non-ascii characters have been transliterated to ascii.";
      }

      /* Call ascii_jpeg() with the parameters */
      ascii_jpeg(colorspace, componentsArray, ascii, imageSize, imageSize);

      /* Update the image dimensions */
      jpegImage.width = imageSize;
      jpegImage.height = imageSize;

      const apfelstrudel_fflate = compress_to_uri(ascii);
      console.log(apfelstrudel_fflate);
      console.log("fflate", ascii.length, apfelstrudel_fflate.length);
      const blabliblu = decompress_from_uri(apfelstrudel_fflate);
      if (!blabliblu)
        console.log("oopsie");
      console.log(ascii == blabliblu);
    }

    /* Handle Download JPEG button */
    const downloadJpegButton = document.getElementById('download-jpeg');

    downloadJpegButton.addEventListener('click', function() {
      if (window.jpeg_blob) {
        const link = document.createElement('a');
        link.href = URL.createObjectURL(window.jpeg_blob);
        link.download = 'ascii.jpeg';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      } else {
        statusLine.textContent = 'Error: No JPEG data available to download.';
      }
    });

    /* Handle Download TXT button */
    const downloadTxtButton = document.getElementById('download-txt');

    downloadTxtButton.addEventListener('click', function() {
      if (window.txt_blob) {
        const blob_url = URL.createObjectURL(window.txt_blob);
        window.open(blob_url, "jpeg.txt");
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      } else {
        statusLine.textContent = 'Error: No TXT data available to download.';
      }
    });

    /* Handle Download Baked image button */
    const downloadPngButton = document.getElementById('download-png');

    downloadPngButton.addEventListener('click', function()
    {
      if (window.png_blob) {
        const link = document.createElement('a');
        link.href = URL.createObjectURL(window.png_blob);
        link.download = 'ascii_baked.png';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      } else {
        statusLine.textContent = 'Error: No PNG data available to download.';
      }
    });

    /* Initial update */
    updateComponents();
  });
</script>

</body>
</html>

